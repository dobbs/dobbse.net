// Generated by CoffeeScript 1.4.0
(function() {
  var Context, Core, Queue, STOP_ITERATION, TAU, Tau, extend, __movePartial, __trigFn, _modTau,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  this.Tau || (this.Tau = Tau = typeof exports !== "undefined" && exports !== null ? exports : {});

  TAU = 2 * Math.PI;

  extend = function() {
    var acc, key, object, objects, _i, _len;
    acc = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = objects.length; _i < _len; _i++) {
      object = objects[_i];
      for (key in object) {
        if (!__hasProp.call(object, key)) continue;
        acc[key] = object[key];
      }
    }
    return acc;
  };

  _modTau = function(angle) {
    return angle - Math.floor(angle / TAU) * TAU;
  };

  __trigFn = function(XorY) {
    return {
      x: Math.cos,
      y: Math.sin
    }[XorY];
  };

  __movePartial = function(XorY, turtle, distance) {
    return turtle[XorY] + __trigFn(XorY)(turtle.angle) * distance;
  };

  Core = {
    turn: function(turtle, angle) {
      return extend({}, turtle, {
        angle: _modTau(turtle.angle + angle)
      });
    },
    move: function(turtle, distance) {
      return extend({}, turtle, {
        x: __movePartial('x', turtle, distance),
        y: __movePartial('y', turtle, distance)
      });
    }
  };

  STOP_ITERATION = function() {
    return STOP_ITERATION;
  };

  Queue = {
    STOP_ITERATION: STOP_ITERATION,
    enQ: function(q, fn) {
      return q.push(fn);
    },
    deQ: function(q) {
      return q.shift();
    },
    runQ: function(q) {
      var fn, result;
      if (!(fn = q[0])) {
        return;
      }
      result = fn();
      if (result !== STOP_ITERATION) {
        return result;
      }
      Queue.deQ(q);
      return Queue.runQ(q);
    },
    emptyQ: function(q) {
      return q.length = 0;
    },
    startQ: function(q, delay) {
      var timer;
      if (delay == null) {
        delay = 5;
      }
      timer = function() {
        Queue.runQ(q);
        return q.timeout = setTimeout(timer, delay);
      };
      return timer();
    },
    stopQ: function(q) {
      clearTimeout(q.timeout);
      return delete q.timeout;
    }
  };

  Context = {
    moveTo: function(context, turtle) {
      context.beginPath();
      return context.moveTo(turtle.x, turtle.y);
    },
    lineTo: function(context, turtle) {
      context.lineTo(turtle.x, turtle.y);
      return context.stroke();
    },
    clearAll: function(context) {
      return context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    }
  };

  extend(Tau, {
    TAU: TAU,
    _modTau: _modTau
  }, {
    moveTurtle: Core.move,
    turnTurtle: Core.turn
  }, Queue, Context, {
    createDemo: function($) {
      var createCanvas, mousedownAdapter, polygonIterator, touchmoveAdapter, _createAngleFromEvent, _createDistanceFromEvent, _heightFromEvent, _widthFromEvent;
      polygonIterator = function(context, turtle, angle, distance, limit) {
        var limitExceeded, lineTo, move, moveTo, turn;
        if (limit == null) {
          limit = 600;
        }
        limitExceeded = function() {
          return limit-- <= 0;
        };
        moveTo = function(turtle) {
          return Context.moveTo(context, turtle);
        };
        lineTo = function(turtle) {
          return Context.lineTo(context, turtle);
        };
        move = function(distance) {
          return turtle = Core.move(turtle, distance);
        };
        turn = function(angle) {
          return turtle = Core.turn(turtle, angle);
        };
        return function() {
          if (limitExceeded()) {
            return STOP_ITERATION;
          }
          moveTo(turtle);
          turn(angle);
          move(distance);
          lineTo(turtle);
          return turtle;
        };
      };
      _widthFromEvent = function(event) {
        return event.view.document.body.clientWidth;
      };
      _heightFromEvent = function(event) {
        return event.view.document.body.clientHeight;
      };
      _createAngleFromEvent = function(event) {
        return TAU * event.pageX / _widthFromEvent(event);
      };
      _createDistanceFromEvent = function(event) {
        var h, w;
        w = _widthFromEvent(event);
        h = _heightFromEvent(event);
        return Math.min(w, h) * event.pageY / h;
      };
      touchmoveAdapter = function(moveHandler) {
        return function(touchevent) {
          var event;
          touchevent.preventDefault();
          event = extend({}, touchevent.originalEvent.changedTouches[0], {
            view: touchevent.view
          });
          return moveHandler(event);
        };
      };
      mousedownAdapter = function(moveHandler) {
        return function(event) {
          var doc;
          doc = event.view.document;
          return $(doc).on('mousemove', moveHandler).on('mouseup', function(e) {
            return $(e.view.document).off('mousemove', moveHandler);
          });
        };
      };
      createCanvas = function($window, q) {
        var $canvas, $document, context, height, moveHandler, width;
        width = $window.width() - 20;
        height = $window.height() - 40;
        $canvas = $("<canvas width=\"" + width + "\" height=\"" + height + "\">");
        context = $canvas[0].getContext('2d');
        $document = $($window[0].document);
        $document.find('body').append('<p>drag to set edge size and angle of rotation, release to let the turtle do its thing</p>').append($canvas);
        moveHandler = function(event) {
          var angle, distance, iter, turtle;
          width = _widthFromEvent(event);
          height = _heightFromEvent(event);
          angle = _createAngleFromEvent(event);
          distance = _createDistanceFromEvent(event);
          turtle = {
            x: Math.floor(width / 2),
            y: Math.floor(height / 2),
            angle: 0
          };
          iter = polygonIterator(context, turtle, angle, distance);
          Context.clearAll(context);
          Queue.emptyQ(q);
          return Queue.enQ(q, iter);
        };
        $document.on('mousedown', mousedownAdapter(moveHandler));
        $document.on('touchmove', touchmoveAdapter(moveHandler));
        return Tau.startQ(q);
      };
      return {
        polygonIterator: polygonIterator,
        createCanvas: createCanvas,
        _createAngleFromEvent: _createAngleFromEvent,
        _createDistanceFromEvent: _createDistanceFromEvent
      };
    }
  });

}).call(this);
