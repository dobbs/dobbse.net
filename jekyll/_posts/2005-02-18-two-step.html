--- 
layout: post
title: "Python, Java, C++: One step forward, two steps back"
date: 2005-02-18T19:12:08
link: https://dobbse.net/thinair/2005/02/two-step.html
---
<p><em>This rant is a cleverly disguised thank-you note to bivio.  I&#39;m lucky to work for a company that prefers dynamic languages.</em></p>

<p>For one of our customers, I&#39;m wrapping a C++ library with python.  As a recovering java geek working in python is a step forward.  But much of the work is actually in C++.  Two steps back.</p>

<p>I&#39;ve used many, many different languages starting with Apple <span class="caps">BASIC</span> and wandering through pascal, HyperTalk, Excel &amp; Word macros, AppleScript, AutoLISP, <span class="caps">DOS</span> batch files (shudder), Turing, MacPerl, Tango, bash, <span class="caps">TCL, </span>Python, <span class="caps">PHP,</span> perl, Java, and JavaScript roughly in that order.  (We&#39;ll just overlook the xml-ish languages like <span class="caps">JSTL, </span>Ant, and Jelly.)</p>

<p>Very few of those languages require an explicit compile step: Pascal, Turing, Java.  Java was my first introduction to a build environment.  Every other language I&#39;ve used has been interpreted and dynamic.  C++ introduces a whole new level of pain in the build step.</p>

<h3>compile and build considered harmful</h3>

<p>This is now my favorite sales pitch against compiled languages: the build process is a huge timesink which brings marginal value to the resulting software.</p>

<p>Working in C++ means working with <em>make</em> just as working in Java means working with <em>ant</em>.  But people don&#39;t write their own Makefiles, they run a <em>configure</em> script.  They don&#39;t write that either.  That gem of a shell script is generated by a collection of things called autotools.  autotools includes <em>aclocal, autoheader, autommake, autoconf</em>.  <em>autoconf</em> is a shell script, the rest are <em>perl</em> scripts and the whole mess depends on a pile of <em>m4</em> macros.  All these C++ programs are depending on <em>sh</em>, and <em>perl</em>, and <em>m4</em> for their assembly.</p>

<p><span class="caps">THAT</span>&#39;S <span class="caps">WAY TOO MANY MOVING PARTS</span>!!  <span class="caps">TOO MANY LAYERS OF CODE GENERATION</span>!!</p>

<p>Here&#39;s a simple news-flash.  Any sufficiently ambitious program in any language needs another program to build it.  <strong><span class="caps">USE A DAMN PROGRAMMING LANGUAGE FOR YOUR BUILD</span>!</strong> I suggest perl or python both of which are probably already installed on your computer.</p>

<p>Of course if you write your build in perl or python, you may get hooked.  You might even decide to just write your program in perl or python and spare yourself the build problems altogether.</p>

<p>Aw, who am I kidding?  What most of us are really writing is resumeware anyway and these days resumeware isn&#39;t written in perl nor python.  (Oops.  I probably wasn&#39;t supposed to tell. ;-)</p>

<p>*eric, the Java programmer, slips into a dream...</p>

<p>So now instead of this to build your Java project:</p>

<p><code>% ant -f my-build.xml build</code></p>

<p>You type this:</p>

<p><code>jython my-build.py build</code></p>

<p>Hmm... I wonder what maven would look like re-written in jython...</p>
